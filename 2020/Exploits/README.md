## Basic Exploitation 

### Using GDB 
So we have this highly vulnerable program vulnerable_1.c and compile it to an 
executable called login. 

We can open this compiled program and in gdb with ```$ gdb login```

Using ```disassemble main``` you can pause execution of the program before being
prompted for a password by setting a breakpoint before the scanf call:

![breakpt](https://raw.githubusercontent.com/scott-robbins/Research/master/2020/Exploits/BreakBeforePrompted.png)


When we get here, one way we might find useful information is looking at memory.
If the program has left hardcoded variables in their code, we can find them as 
shown and exploit this knowledge!!

![leaked](https://raw.githubusercontent.com/scott-robbins/Research/master/2020/Exploits/gdb_peek.png)

Maybe we aren't lucky enough to have a hardcoded string left in the binary. What then?

One trick is to actually patch the code of a binary. In this case, there's a strcmp 
responsible for whether or not we get ACCESS GRANTED. So why not just change the 
code to do the opposite logic (if our password is *wrong* we're given access)?
 
[![VimHack](https://img.youtube.com/vi/0GXW0EsP9h4/0.jpg)](https://www.youtube.com/watch?v=0GXW0EsP9h4)

In the video above, I use this technique to get around the login for vulnerable_2.c, which doesn't
leave a hardcoded password. In fact, the password is created randomly at run time, so I don't actually 
know what it will be. But using vim, we can directly edit hex with ```:%!xxd``` and then recover the binary
by reversing back using ```:%!xxd -r``` and saving our work ```:wq!```. 

In the video above, we said we want to flip the logic to give access only with the *wrong* password. In this
case it's as easy as changing one byte. The if statement in vulnerable_2.c will be a JNZ (Jump if not zero)
command, represented by 75 in [Intel x86](http://unixwiz.net/techtips/x86-jumps.html). If we can change this
to a 74, it will flip the logic to JZ (jump if zero).
